/*Let's talk a little bit about the static access modifier. At its core what it means is that we can only access ether a property of a method of a class, not having it instantiated. And it sort of becomes a utility function to a degree. That's really how I think of static methods and properties. Is they're there for context, they provide a utility. And we use them, but we don't actually instantiate them. That's the intent. So let's give an example. I'll even go a little bit deeper and give an example of how we can do some cool object-oriented programming implementation to give you an idea of how you might use static methods. So if you remember earlier we have our Message class that we defined. And now we have this Messages, which you would imagine would be an array of Messages. Now let's say we wanted to create a static method. We can with the keyword static and let's say we want to return the valid Messages which will just be defined as a value that has a length greater than zero for Message. And we're expecting to return back a Message array. And with that we're going to take in some messages. So first thing you have to know about static methods is they cannot reference the this keyword unless that property or method is also static itself. Because you can't reference something outside of the instantiation in a static method. And thus the static properties in methods need to be static to be used in accordance. So here we'll just do a little bit of logic where we're expecting messages to return values where the message. Let's trim it, right? That's how I do it in the real world. And length is greater than zero. We now have a way of passing in a couple messages and saying hey just return the valid ones. And we would never even have to create a static method .getValidMessage. And then we'd pass in whatever we want. In this case we'll just pass in an empty array. Now how does that differ from let's say we wanted to go and create a version of this but would be an instantiated version? Well before we do that one thing to note is that you can have a public keyword on here. But by default it's public, right? You can't have a static method without it being public. It doesn't make a lot of sense. 'Cause the only way to get access to it is to invoke it from outside the class. But it is public by default. Even though should I do private or protected it's not going to make any sense, it's going to give you an error. Now I want to showcase something I do quite a bit. Is that when I extend from an array. Like you have a Message class and you think, "Ah I need Messages I wish I could extend it." You can extend these prototypes, like array. And you could pass in a Message value. Now when we do this, to duplicate the functionality that would be expected. We'd go ahead. And you'll notice that I can actually rename this the same exact name. Have the same exact signature of getValidMessages with messages. And the reason for that is they're never going to be invoked in the same way. Our static method will be invoked without our Messages class being instantiated. While our non-static public method will need instantiation for it to be invoked. And by extending the array prototype like that we can simply return this, which references the values in the array. I'll filter and duplicate the logic that we have down here. Filter. In the real world you'd never have two circumstances where you'd have a static method and a non-static method that does the same thing. Doesn't make a whole lot of sense. But it is worth mentioning. This is sort of the closest you're going to get to truly overloading methods. Although one is for the static way and one is for the non static way. But again, static, no instantiation. Everything else, you're going to instantiate your class.*/

export class Message {
    title: string;
    message: string;
    isSent: boolean;
}

export class Messages {

}
