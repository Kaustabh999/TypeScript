/*Read only is the last major access modifier that stops us from overwriting a value. It does pretty much exactly what you think it would do. Gives us the readability only on a property. Now let's take a look at our message class. And like most models that come from a server for instance, you'd expect there to be some sort of ID or primary key, and read only is a very practical and realistic example of how that might work. So if we have read only on an ID, we'll say this is a string, this is going to give us the ability to not overwrite this value once it's instantiated. So we can make this private if for some reason we only needed to use it in our actual class itself. We could make it public if we want to read it from outside the class. And we could even make it protected as we would other places. We'll go ahead and just leave it as public so that we can show it for demo purposes. You'll also notice that in our constructor, if all we were passing for instance was an ID, we'll have the ability to set the ID within our constructor. We'll also have the ability to use readonly instead of default value here for message which although it wouldn't make a lot of sense to overwrite it, it is something that we could do if you want to give it an initial value there. It doesn't make sense in terms of a primary key but it may in other circumstances. Now let's go ahead and just see that this is going to error out when we create a message here. When we try to an access the ID, we'll be able to access it, but we won't be able to reassign it. So I'll just put in a string of abc123. And if we wanted to do something with it such as read it, we would, however, if we were to go and let's set this to 123abc, what we'd actually see here is that hey, this is read-only, you're trying to reassign the value, thus breaking the access modification limiting that we've set up which is what access modifiers and encapsulation is all about.*/

export class Message {
    title: string;
    message: string;
    isSent: boolean;
}
